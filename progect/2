/* Программа C++ для реализации обхода методом Джарвиса найти минимальную выпуклую оболочку. */
#include <bits/stdc++.h>
using namespace std;

struct Point
{
    int x, y;
};

/* Найти ориентацию упорядоченного триплета (p, q, r). */
/* Функция возвращает следующие значения */
/* 0 -> p, q и r коллинеарны */
/* 1 -> ориентация по часовой стрелке */
/* 2 -> ориентация против часовой стрелки */
int orientation(Point p, Point q, Point r)
{
    int val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);

    if (val == 0) return 0;  /* коллинеарны */
    return (val > 0)? 1: 2; /* по или против часовой стрелки */
}

/* Печатает выпуклую оболочку множества из n точек. */
void convexHull(vector<Point>& A)
{
    int n = A.size();

    /* инициализация вектора результатов */
    vector<Point> hull;
    if (n == 0) return;
    /* Если точек меньше трёх */
    if (n < 3){
        for (int i = 0; i < n; i++)
            hull.push_back(A[i]);;
    } else {


        /* Находим самую левую точку */
        int l = 0;
        for (int i = 1; i < n; i++)
            if (A[i].x < A[l].x || (A[i].x == A[l].x && A[i].y < A[l].y))
                l = i;

            /* Начнем с самой левой точки, продолжаем движение против часовой стрелки
            пока не дойдем до начальной точки. Этот цикл работает O(h)
            раз, где h - количество вершин в результате. */
        int p = l, q;
        do
        {
            /* Добавляем точку в вектор */
            hull.push_back(A[p]);


            /* Ищем точку «q», такую, чтобы ориентация (p, x, q)
            была против часовой стрелки для всех точек 'x'. Идея - хранить последнюю
            посещенную точку с значением ориентации 2 в q. Если ориентация какой-либо
            точки «i» вместе с «p» и текущей «q» равна 2 тогда обновляем «q». */
            q = (p+1)%n;
            for (int i = 0; i < n; i++)
            {
                /*Если ориентация «i» вместе с «p» и текущей «q» то обновляем «q» */
                if (orientation(A[p], A[i], A[q]) == 2)
                    q = i;
            }

            /* Теперь q является той следующей после p точкой, входящий в МВО.
            Устанавливаем p = q для следующей итерации, а q добавляется в вектор результатов */
            p = q;

        } while (p != l);  /* Пока не дойдём до первой точки */

    }

    /* Вывод результата */
    for (int i = 0; i < hull.size(); i++){
        if ( hull[i].x != hull[i-1].x || hull[i].y != hull[i-1].y ){
            cout << "(" << hull[i].x << ", "
        << hull[i].y << ")\n";
        }

    }
}

typedef vector<Point> points;

/* Драйвер программы для тестирования функций */
int main()
{
    int n;
    cin >> n;
    points A;
    for (int i = 0; i < n; i++){
        Point temp;
        cin >> temp.x >> temp.y;
        A.push_back(temp);
    }
    convexHull(A);
    return 0;
}
