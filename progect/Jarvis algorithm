/* Программа C++ для реализации обхода методом Джарвиса, чтобы найти минимальную выпуклую оболочку. */
#include <bits/stdc++.h>
using namespace std;

/* множество Pair - пары целых чисел */
#define Pair pair<double, double>

/* Сохраняет результаты (точки МВО) */
set <Pair> hull;

/* Найти ориентацию упорядоченного триплета (p, q, r). */
/* Функция возвращает следующие значения */
/* 0 -> p, q и r коллинеарны */
/* 1 -> ориентация по часовой стрелке */
/* 2 -> ориентация против часовой стрелки */
double orientation(Pair p, Pair q, Pair r)
{
    double val = (q.second - p.second) * (r.first - q.first) -
              (q.first - p.first) * (r.second - q.second);

    if (val == 0) return 0;  /* коллинеарны */
    return (val > 0)? 1: 2; /* по или против часовой стрелки */
}

/* Печатает выпуклую оболочку множества из n точек. */
void convexHull(Pair A[], int n)
{
    /* если точек нет - оболочки тоже нет */
    if (n == 0) return;

    /* если точка одна - в МВО тоже будет только эта точка */
    if (n == 1)
    {
        hull.insert(A[0]);
    }

    /* если точка две - в МВО также будут только они,
    если они совпадаю, точка будет только одна */
    if (n == 2)
    {
        hull.insert(A[0]);
        if (A[0].first != A[1].first || A[0].second != A[1].second)
        hull.insert(A[1]);
    }

    /* a [i].second -> y - координата i - й точки */

        /* Находим самую левую точку */
        int l = 0;
        for (int i = 1; i < n; i++)
            if (A[i].first < A[l].first || (A[i].first == A[l].first && A[i].second < A[l].second))
                l = i;

            /* Начнем с самой левой точки, продолжаем движение против часовой стрелки
            пока не дойдем до начальной точки. Этот цикл работает O(h)
            раз, где h - количество вершин в результате. */
        int p = l, q;
        do
        {
            /* Добавляем точку в вектор */
            hull.insert(A[p]);


            /* Ищем точку «q», такую, чтобы ориентация (p, x, q)
            была против часовой стрелки для всех точек 'x'. Идея - хранить последнюю
            посещенную точку с значением ориентации 2 в q. Если ориентация какой-либо
            точки «i» вместе с «p» и текущей «q» равна 2 тогда обновляем «q». */
            q = (p+1)%n;
            for (int i = 0; i < n; i++)
            {
                /*Если ориентация «i» вместе с «p» и текущей «q» то обновляем «q» */
                if (orientation(A[p], A[i], A[q]) == 2)
                    q = i;
            }

            /* Теперь q является той следующей после p точкой, входящий в МВО.
            Устанавливаем p = q для следующей итерации, а q добавляется в вектор результатов */
            p = q;

        } while (p != l);  /* Пока не дойдём до первой точки */

    /* Вывод результата */
    cout << "The points in Convex Hull are:\n";
    while (!hull.empty())
    {
        cout << "(" <<( *hull.begin()).first << "; "
             << (*hull.begin()).second << ")\n";
        hull.erase(hull.begin());
    }
}

/* Драйвер программы для тестирования функций */
int main()
{
    int n;
    cin >> n;
    Pair a[n];
    for (int i = 0; i < n; i++){
        double temp1, temp2;
        cin >> temp1 >> temp2;
        a[i] = {temp1, temp2};
    }
    convexHull(a, n);
    return 0;
}
