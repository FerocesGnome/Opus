#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
struct pt{
    double x, y;
};
bool cmp (pt a, pt b){ //для сортировки
    return (a.x < b.x || (a.x == b.x && a.y < b.y));
}
bool cw (pt a, pt b, pt c){ //для проверки правого поворота
    return ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x) < 0);
}
bool ccw (pt a, pt b, pt c){ //для проверки левого поворота
    return ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x) > 0);
}
void convex_hull(vector<pt>& a){
    if (a.size() == 1) return;
    sort (a.begin(), a.end(), &cmp);
    pt p1 = a[0], p2 = a.back(); //разбиение с помощью прямой
    vector <pt> up, down;
    up.push_back(p1);
    down.push_back(p2);
    for (size_t i = 1; i < a.size(); i++){
        if (i == a.size() - 1 || cw(p1, a[i], p2)){
            while (up.size() >= 2 && cw(up[up.size()-2], up[up.size()-1], a[i]) == 0)
                up.pop_back();
            up.push_back(a[i]);
        }
        if (i == a.size() - 1 || ccw(p1, a[i], p2)){
            while (down.size() >= 2 && ccw(down[down.size()-2], down[down.size()-1], a[i]) == 0)
                down.pop_back();
            down.push_back(a[i]);
        }
    }
    a.clear();
    for (size_t i = 0; i < up.size(); i++){
        a.push_back(up[i]);
    }
    for (size_t i = down.size() - 2; i > 0; i--){
        a.push_back(down[i]);
    }
}

typedef vector<pt> vec_point;

int main(){
    int n;
    cin >> n;
    vec_point a;
    pt temp;
    for (int i = 0; i < n; i++){
        cin >> temp.x >> temp.y;
        a.push_back(temp);
    }
    convex_hull(a);
    for (int i = 0; i < a.size(); i++){
        cout << a[i].x << ";" << a[i].y << endl;
    }
    return 0;
}
